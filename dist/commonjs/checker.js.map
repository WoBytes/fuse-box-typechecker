{"version":3,"sources":["../src/checker.ts"],"names":[],"mappings":"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","file":"checker.js","sourcesContent":["import * as ts from 'typescript';\r\nimport chalk from 'chalk';\r\nimport * as path from 'path';\r\nimport * as fs from 'fs';\r\n\r\nimport { IInternalTypeCheckerOptions, END_LINE, ITSLintError, ITSError } from './interfaces';\r\n\r\nimport * as TSLintTypes from 'tslint'; // Just use types\r\nlet tslint: typeof TSLintTypes | null;\r\ntry {\r\n    tslint = require('tslint');\r\n} catch {\r\n    tslint = null;\r\n}\r\n\r\nconst entries: any = require('object.entries');\r\n\r\nif (!Object.entries) {\r\n    entries.shim();\r\n}\r\n\r\n\r\ntype TypeCheckError = ITSLintError | ITSError;\r\nfunction isTSError(error: TypeCheckError) {\r\n    return (<ITSError>error).code !== undefined;\r\n}\r\n\r\nexport class Checker {\r\n\r\n    // options that will be used when checking and printing results\r\n    private options: IInternalTypeCheckerOptions;\r\n\r\n    // typescript program\r\n    private program: ts.Program;\r\n\r\n    // time used to do typecheck/linting\r\n    private elapsedInspectionTime: number;\r\n\r\n    // type diagonstic returned by typescript\r\n    private tsDiagnostics: ts.Diagnostic[];\r\n\r\n    // lint result returned by tsLint\r\n    private lintFileResult: TSLintTypes.LintResult[];\r\n\r\n\r\n    constructor() {\r\n        // nothing atm\r\n    }\r\n\r\n\r\n    public inspectCode(options: IInternalTypeCheckerOptions) {\r\n        this.options = options;\r\n\r\n\r\n        // parse it right away, no need to wait...\r\n        const parseConfigHost: any = {\r\n            fileExists: ts.sys.fileExists,\r\n            readDirectory: ts.sys.readDirectory,\r\n            readFile: ts.sys.readFile,\r\n            useCaseSensitiveFileNames: true\r\n        };\r\n\r\n        // take the time\r\n        let inspectionTimeStart = new Date().getTime();\r\n\r\n        // get program and get diagnostics and store them diagnostics\r\n        const parsed = ts.parseJsonConfigFileContent(this.options.tsConfigJsonContent, parseConfigHost, options.basePath || '.', undefined);\r\n        this.program = ts.createProgram(parsed.fileNames, parsed.options, undefined, this.program);\r\n\r\n\r\n        // get errors and tag them;\r\n        this.tsDiagnostics = [];\r\n        let optionsErrors = this.program.getOptionsDiagnostics().map((obj) => {\r\n            // tag em so we know for later\r\n            (<any>obj)._type = 'options';\r\n            return obj;\r\n        });\r\n        this.tsDiagnostics = this.tsDiagnostics.concat(optionsErrors);\r\n\r\n\r\n\r\n        let globalErrors = this.program.getGlobalDiagnostics().map((obj) => {\r\n            (<any>obj)._type = 'global';\r\n            return obj;\r\n        });\r\n        this.tsDiagnostics = this.tsDiagnostics.concat(globalErrors);\r\n\r\n\r\n\r\n        let syntacticErrors = this.program.getSyntacticDiagnostics().map((obj) => {\r\n            (<any>obj)._type = 'syntactic';\r\n            return obj;\r\n        });\r\n        this.tsDiagnostics = this.tsDiagnostics.concat(syntacticErrors);\r\n\r\n\r\n\r\n        let semanticErrors = this.program.getSemanticDiagnostics().map((obj) => {\r\n            (<any>obj)._type = 'semantic';\r\n            return obj;\r\n        });\r\n        this.tsDiagnostics = this.tsDiagnostics.concat(semanticErrors);\r\n\r\n\r\n        // get tslint if json file is supplied\r\n        this.lintFileResult = [];\r\n        if (options.tsLint) {\r\n\r\n            if (!tslint) {\r\n                this.writeText(\r\n                    chalk.red(`\\nMake sure to have ${chalk.bgWhiteBright('tslint')} installed if you use the \"tsLint\" option:\\n`) +\r\n                    chalk.redBright('npm install --save-dev tslint\\n\\n')\r\n                );\r\n                throw new Error('tslint not installed');\r\n            }\r\n\r\n            // get full path\r\n            let fullPath = path.resolve(this.options.basePath, options.tsLint);\r\n\r\n            // gets the files, lint every file and store errors in lintResults\r\n            let files = tslint.Linter.getFileNames(this.program);\r\n\r\n            // get tslint configuration\r\n            const tsLintConfiguration = tslint.Configuration.findConfiguration(fullPath, this.options.basePath).results;\r\n\r\n            // lint the files\r\n            this.lintFileResult =\r\n                files.map(file => {\r\n                    // get content of file\r\n                    let fileContents: any = this.program.getSourceFile(file);\r\n                    fileContents = fileContents ? fileContents.getFullText() : '';\r\n\r\n                    // create new linter using lint options and tsprogram\r\n                    const linter = new tslint!.Linter((<TSLintTypes.ILinterOptions>options.lintoptions), this.program);\r\n\r\n                    // lint file using filename, filecontent, and tslint configuration\r\n                    linter.lint(file, fileContents, tsLintConfiguration);\r\n\r\n                    // return result\r\n                    return linter.getResult();\r\n                }).filter((result) => {\r\n                    // only return the one with erros\r\n                    return result.errorCount ? true : false;\r\n                });\r\n        }\r\n\r\n        // save elapsed check time\r\n        this.elapsedInspectionTime = new Date().getTime() - inspectionTimeStart;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * print result\r\n     *\r\n     */\r\n    public printResult(isWorker?: boolean) {\r\n\r\n        // consts\r\n        const print = this.writeText;\r\n        const program = this.program;\r\n        const options = this.options;\r\n\r\n        // print header\r\n        print(\r\n            chalk.bgWhite(\r\n                chalk.black(`${END_LINE}Typechecker plugin(${options.type}) ${options.name}`)\r\n            ) +\r\n            chalk.white(`.${END_LINE}`)\r\n        );\r\n\r\n        // print time\r\n        print(\r\n            chalk.grey(`Time:${new Date().toString()} ${END_LINE}`)\r\n        );\r\n\r\n        // get the lint errors messages\r\n        let lintErrorMessages: TypeCheckError[] = this.processLintFiles();\r\n\r\n        // loop diagnostics and get the errors messages\r\n        let tsErrorMessages: TypeCheckError[] = this.processTsDiagnostics();\r\n\r\n        // combine errors and print if any\r\n        let combinedErrors: TypeCheckError[] = tsErrorMessages.concat(lintErrorMessages);\r\n\r\n        // group by filename\r\n        let groupedErrors: { [k: string]: TypeCheckError[] } = {};\r\n        combinedErrors.forEach((error: TypeCheckError) => {\r\n            if (!groupedErrors[error.fileName]) {\r\n                groupedErrors[error.fileName] = [] as TypeCheckError[];\r\n            }\r\n\r\n            groupedErrors[error.fileName].push(error);\r\n        });\r\n\r\n        let allErrors = Object.entries(groupedErrors)\r\n            .map(([fileName, errors]) => {\r\n                const short = this.options.shortenFilenames;\r\n                const fullFileName = path.resolve(fileName);\r\n                const shortFileName = fullFileName.split(options.basePath).join('.');\r\n                return chalk.white(`└── ${shortFileName}`) + END_LINE + errors.map((err: TypeCheckError) => {\r\n                    let text = chalk.red('   |');\r\n                    if (isTSError(err)) {\r\n                        text += chalk[err.color](` ${short ? shortFileName : fullFileName} (${err.line},${err.char}) `);\r\n                        text += chalk.white(`(${(<ITSError>err).category}`);\r\n                        text += chalk.white(`${(<ITSError>err).code})`);\r\n                        text += ' ' + (<ITSError>err).message;\r\n                    } else {\r\n                        text += chalk[err.color](` ${short ? shortFileName : fullFileName} (${err.line + 1},${err.char + 1}) `);\r\n                        text += chalk.white(`(${(<ITSLintError>err).ruleSeverity}:`);\r\n                        text += chalk.white(`${(<ITSLintError>err).ruleName})`);\r\n                        text += ' ' + (<ITSLintError>err).failure;\r\n                    }\r\n\r\n                    return text;\r\n                }).join(END_LINE);\r\n            });\r\n\r\n        // print if any\r\n        if (allErrors.length > 0) {\r\n            // insert header\r\n            allErrors.unshift(\r\n                chalk.underline(`${END_LINE}File errors`) + chalk.white(':') // fix windows\r\n            );\r\n            print(allErrors.join(END_LINE));\r\n        }\r\n\r\n        // print option errors\r\n        if (program.getOptionsDiagnostics().length) {\r\n            print(chalk.underline(`${END_LINE}${END_LINE}Option errors`) + chalk.white(`:${END_LINE}`));\r\n            let optionErrorsText = Object.entries(program.getOptionsDiagnostics())\r\n                .map(([no, err]) => {\r\n                    let text = no + ':';\r\n                    let messageText = (<any>err).messageText;\r\n                    if ((typeof messageText === 'object') && (messageText !== null)) {\r\n                        messageText = JSON.stringify(messageText);\r\n                    }\r\n                    text = chalk[options.yellowOnOptions ? 'yellow' : 'red']\r\n                        (`└── tsConfig: `);\r\n                    text += chalk.white(`(${(<any>err).category}:`);\r\n                    text += chalk.white(`${(<any>err).code})`);\r\n                    text += chalk.white(` ${messageText}`);\r\n                    return text;\r\n                });\r\n            print(optionErrorsText.join(END_LINE));\r\n        }\r\n\r\n        // print global errors\r\n        // todo: this needs testing, how do I create a global error??\r\n        /* try {\r\n            if (program.getGlobalDiagnostics().length) {\r\n                print(chalk.underline(`${END_LINE}${END_LINE}Global errors`) + chalk.white(`:${END_LINE}`));\r\n                let optionErrorsText = Object.entries(program.getGlobalDiagnostics())\r\n                    .map(([no, err]) => {\r\n                        let text = no + ':';\r\n                        text = chalk[options.yellowOnGlobal ? 'yellow' : 'red']\r\n                            (`└── tsConfig: `);\r\n                        text += chalk.white(`(${(<any>err).category}:`);\r\n                        text += chalk.white(`${(<any>err).code})`);\r\n                        text += chalk.white(` ${(<any>err).messageText}`);\r\n                        return text;\r\n                    });\r\n                print(optionErrorsText.join(END_LINE));\r\n            }\r\n        } catch (err) {\r\n            console.log(`Global error`);\r\n        } */\r\n\r\n        // time for summary >>>>>\r\n\r\n        // get errors totals\r\n        let optionsErrors = program.getOptionsDiagnostics().length;\r\n        let globalErrors = program.getGlobalDiagnostics().length;\r\n        let syntacticErrors = program.getSyntacticDiagnostics().length;\r\n        let semanticErrors = program.getSemanticDiagnostics().length;\r\n        let tsLintErrors = lintErrorMessages.length;\r\n        let totalsErrors = optionsErrors + globalErrors + syntacticErrors + semanticErrors + tsLintErrors;\r\n\r\n\r\n\r\n        // if errors, show user\r\n        if (totalsErrors) {\r\n\r\n            // write header\r\n            print(\r\n                chalk.underline(`${END_LINE}${END_LINE}Errors`) +\r\n                chalk.white(`:${totalsErrors}${END_LINE}`)\r\n            );\r\n\r\n            print(\r\n                chalk[optionsErrors ? options.yellowOnOptions ? 'yellow' : 'red' : 'white']\r\n                    (`└── Options: ${optionsErrors}${END_LINE}`)\r\n            );\r\n\r\n            print(\r\n                chalk[globalErrors ? options.yellowOnGlobal ? 'yellow' : 'red' : 'white']\r\n                    (`└── Global: ${globalErrors}${END_LINE}`)\r\n            );\r\n\r\n            print(\r\n                chalk[syntacticErrors ? options.yellowOnSyntactic ? 'yellow' : 'red' : 'white']\r\n                    (`└── Syntactic: ${syntacticErrors}${END_LINE}`)\r\n            );\r\n\r\n            print(\r\n                chalk[semanticErrors ? options.yellowOnSemantic ? 'yellow' : 'red' : 'white']\r\n                    (`└── Semantic: ${semanticErrors}${END_LINE}`)\r\n            );\r\n\r\n            print(\r\n                chalk[tsLintErrors ? options.yellowOnLint ? 'yellow' : 'red' : 'white']\r\n                    (`└── TsLint: ${tsLintErrors}${END_LINE}${END_LINE}`)\r\n            );\r\n\r\n            if (options.emit) {\r\n                print(\r\n                    chalk.grey(`Skipping emit file${END_LINE}`)\r\n                );\r\n            }\r\n\r\n        } else {\r\n            // if there no errors, then also give some feedback about this, so they know its working\r\n            print(\r\n                chalk.grey(`All good, no errors :-)${END_LINE}`)\r\n            );\r\n\r\n            if (options.emit) {\r\n                print(\r\n                    chalk.grey(`Getting ready to emit files${END_LINE}`)\r\n                );\r\n                try {\r\n                    if (options.clearOnEmit) {\r\n                        let outputFolder: any = program.getCompilerOptions().outDir;\r\n                        let deleteFolder = function (folder: string) {\r\n                            folder = path.join(folder);\r\n                            if (fs.existsSync(folder)) {\r\n                                fs.readdirSync(folder).forEach(function (file: string) {\r\n                                    let curPath = folder + '/' + file;\r\n                                    if (fs.lstatSync(curPath).isDirectory()) { // recurse\r\n                                        deleteFolder(curPath);\r\n                                    } else { // delete file\r\n                                        fs.unlinkSync(curPath);\r\n                                    }\r\n                                });\r\n                                fs.rmdirSync(folder);\r\n                            }\r\n                        };\r\n                        if (!outputFolder) {\r\n                            console.warn('output filder missing');\r\n                        } else {\r\n                            print(\r\n                                chalk.grey(`clearing output folder${END_LINE}`)\r\n                            );\r\n                            deleteFolder(outputFolder);\r\n                            print(\r\n                                chalk.grey(`Output folder cleared${END_LINE}`)\r\n                            );\r\n                            program.emit();\r\n                            print(\r\n                                chalk.grey(`Files emittet${END_LINE}`)\r\n                            );\r\n                        }\r\n                    } else {\r\n                        program.emit();\r\n                        print(\r\n                            chalk.grey(`Files emittet${END_LINE}`)\r\n                        );\r\n                    }\r\n                } catch (error) {\r\n                    print(\r\n                        chalk.red(`emitting files failed${END_LINE}`)\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        print(\r\n            chalk.grey(`Typechecking time: ${this.elapsedInspectionTime}ms${END_LINE}`)\r\n        );\r\n\r\n\r\n        // final check how to end the checker, throw, exit or keep alive\r\n\r\n        switch (true) {\r\n\r\n            // if throwError is set then callback and quit\r\n            case options.throwOnGlobal && globalErrors > 0:\r\n            case options.throwOnOptions && optionsErrors > 0:\r\n            case options.throwOnSemantic && semanticErrors > 0:\r\n            case options.throwOnTsLint && tsLintErrors > 0:\r\n            case options.throwOnSyntactic && syntacticErrors > 0:\r\n                if (process.send) {\r\n                    process.send('error');\r\n                } else {\r\n                    print(chalk.grey(`error typechecker${END_LINE}${END_LINE}`));\r\n                }\r\n                // exit with error\r\n                process.exit(1);\r\n                break;\r\n\r\n            // if quit is set and its a worker, then post message and callback to main tread and tell its done\r\n            case options.quit && isWorker:\r\n                print(chalk.grey(`Quiting typechecker${END_LINE}${END_LINE}`));\r\n\r\n                // since Im a worker I need to send back a message;\r\n                (<any>process).send('done');\r\n                break;\r\n\r\n            // if quit is set and not worker, then just post messeage\r\n            case options.quit && !isWorker:\r\n                print(chalk.grey(`Quiting typechecker${END_LINE}${END_LINE}`));\r\n                break;\r\n\r\n            // default action\r\n            default:\r\n                print(chalk.grey(`Keeping typechecker alive${END_LINE}${END_LINE}`));\r\n        }\r\n\r\n        return totalsErrors;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * write to screen helper\r\n     *\r\n     */\r\n    private writeText(text: string) {\r\n        ts.sys.write(text);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * loops lint failures and return pretty failure string ready to be printed\r\n     *\r\n     */\r\n    private processLintFiles(): ITSLintError[] {\r\n        const options = this.options;\r\n        const erroredLintFiles = this.lintFileResult\r\n            .filter((fileResult: TSLintTypes.LintResult) => fileResult.failures);\r\n        const errors = erroredLintFiles\r\n            .map(\r\n                (fileResult: TSLintTypes.LintResult) =>\r\n                    fileResult.failures.map((failure: any) => ({\r\n                        fileName: failure.fileName,\r\n                        line: failure.startPosition.lineAndCharacter.line,\r\n                        char: failure.startPosition.lineAndCharacter.character,\r\n                        ruleSeverity: failure.ruleSeverity.charAt(0).toUpperCase() + failure.ruleSeverity.slice(1),\r\n                        ruleName: failure.ruleName,\r\n                        color: options.yellowOnLint ? 'yellow' : 'red',\r\n                        failure: failure.failure\r\n                    }))).reduce((acc, curr) => acc.concat(curr), []);\r\n        return errors;\r\n    }\r\n\r\n    /**\r\n     * loops ts failures and return pretty failure string ready to be printed\r\n     *\r\n     */\r\n    private processTsDiagnostics(): ITSError[] {\r\n        const options = this.options;\r\n        return this.tsDiagnostics\r\n            .filter((diag: any) => diag.file)\r\n            .map((diag: any) => {\r\n                // set color from options\r\n                let color: string;\r\n                switch (diag._type) {\r\n                    case 'options':\r\n                        color = options.yellowOnOptions ? 'yellow' : 'red';\r\n                        break;\r\n                    case 'global':\r\n                        color = options.yellowOnGlobal ? 'yellow' : 'red';\r\n                        break;\r\n                    case 'syntactic':\r\n                        color = options.yellowOnSyntactic ? 'yellow' : 'red';\r\n                        break;\r\n                    case 'semantic':\r\n                        color = options.yellowOnSemantic ? 'yellow' : 'red';\r\n                        break;\r\n                    default:\r\n                        color = 'red';\r\n                }\r\n                const {\r\n                    line,\r\n                    character\r\n                } = diag.file.getLineAndCharacterOfPosition(diag.start);\r\n                return {\r\n                    fileName: diag.file.fileName,\r\n                    line: line + 1, // `(${line + 1},${character + 1})`,\r\n                    message: ts.flattenDiagnosticMessageText(diag.messageText, END_LINE),\r\n                    char: character + 1,\r\n                    color: color,\r\n                    category: `${ts.DiagnosticCategory[diag.category]}:`,\r\n                    code: `TS${diag.code}`\r\n                };\r\n            });\r\n    }\r\n}\r\n"],"sourceRoot":"src/"}